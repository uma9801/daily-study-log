#Numpy #python 
# Numpy
## インポート
`import numpy as np`
## ndarray
`np.array()`で作成
N-Dimensional Array : N次元配列
- 処理速度が速い
	- PythonはC言語やJavaに比べてfor文によるループ処理が非常に遅い。
	- NumPyで代用できるものはNumPyを使うようにする。
- 配列の扱い方が柔軟
	- 真偽リストによる参照、行列変換など。
- コードがシンプルで綺麗になる
	- for文を使わず柔軟な配列操作ができるため、記述量が減り可読性が上がる。
高負荷な処理は、Pythonのlist型を使わずに、ndarrayにデータを格納することが重要。
## list型をndarrayに変換
`np.array(リスト)`
例
```python
array_2 = np.array([[[1,2,3,4,5],
                     [6,7,8,9,10]],
                    [[11,12,13,14,15],
                     [16,17,18,19,20]],
                    [[21,22,23,24,25],
                     [26,27,28,29,30]]])
array_2
```
実行結果
```
array([[[ 1,  2,  3,  4,  5],
        [ 6,  7,  8,  9, 10]],

       [[11, 12, 13, 14, 15],
        [16, 17, 18, 19, 20]],

       [[21, 22, 23, 24, 25],
        [26, 27, 28, 29, 30]]])
```
3つの要素を持ち（3次元配列）の、それぞれの要素が2つの行・5つの列を持つ。
## ndarrayの次元数・要素数確認
`.shape`
```python
array_2.shape
```
実行結果
```
(3, 2, 5)
```
つまり、(最も外側の配列における要素数, 間の要素数, 最も内側の配列における要素数)
次元が増えればその分、間が増える。

`.size`
```python
array_2.size # 30
```

## 1ずつ増加する等差数列のndarrayを作成
`np.arange()`
```python
np.arange(5) # [0, 1, 2, 3, 4]
np.arange(19703,25095) # [19703, 19704, 19705, ..., 25092, 25093, 25094]
```
## 要素が全て0や1の多次元配列を作成
`np.ones()`
`np.zeros()`
```python
np.zeros((3,15))
```
実行結果
```
array([[0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]])
```

```python
array_ones = np.ones((3,3,3))
array_ones
```
実行結果
```
array([[[1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.]],

       [[1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.]],

       [[1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.]]])
```
## 次元数の変更（ndarrayの形状変更）
`pd.reshape(ndarray, 次元数)`
```python
np.reshape(array_ones, (1, 3, 9))
```
実行結果
```
array([[[1., 1., 1., 1., 1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1., 1., 1., 1., 1.]]])
```
変更前の各次元の要素数累積 = 変更後の各次元の要素数累積
(3,3,3) = (1, 3, 9) : 27 = 27
- 次元数の自動設定
`pd.reshape()`の次元に-1を指定すると、その次元は自動的に要素数が決定される。
- 2つ以上の次元に-1を指定するとエラーになる。
- 次元数が合わなくてもエラーになる。
```python
np.reshape(array_ones, (3, -1, 3))
```
実行結果
```
array([[[1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.]],

       [[1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.]],

       [[1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.]]])
```
`pd.resize(ndarray, 次元数)`
- 次元数が異なる場合は、同じ要素を繰り返して補完される。
```python
array_3 = np.array([3,5,3,5,7,4]) # array([3, 5, 3, 5, 7, 4])
np.resize(array_3, [3,3,3,3])
```
実行結果
```
array([[[[3, 5, 3],
         [5, 7, 4],
         [3, 5, 3]],

        [[5, 7, 4],
         [3, 5, 3],
         [5, 7, 4]],

        [[3, 5, 3],
         [5, 7, 4],
         [3, 5, 3]]],


       [[[5, 7, 4],
         [3, 5, 3],
         [5, 7, 4]],

        [[3, 5, 3],
         [5, 7, 4],
         [3, 5, 3]],

        [[5, 7, 4],
         [3, 5, 3],
         [5, 7, 4]]],


       [[[3, 5, 3],
         [5, 7, 4],
         [3, 5, 3]],

        [[5, 7, 4],
         [3, 5, 3],
         [5, 7, 4]],

        [[3, 5, 3],
         [5, 7, 4],
         [3, 5, 3]]]])
```
## 転換行列
`ndarray.T`
行と列を入れ替える（転換する）
行だった要素が列の並びで、列だった要素が行の並びで配置される。
## 一次元化
`ndarray.flatten()`
一次元配列になる。
**.flatten()は常にコピーを返す**ため、変更しても元の値は変わらない。
## （木曜定例）ChatGPTを使ったセルフメンタリング実施
