# 後で調べる
（イ）ミュータブルオブジェクトの原理
a = bとa = copy(b)の違いを詳しく。（ガワも同じidなのがa=b、ガワが違って中身が〃なのがcopyまではOK）
ミュータブルオブジェクトのidについて、関数内での挙動を確認する
Pixel6aとPC接続でマイク使用（WO Mic, AudioRelay）
# Pythonの参照渡しについて  
- ミュータブルなオブジェクト（変更可能なオブジェクト）  
	- リスト、辞書、セットなど  
	- 関数によって、参照元の値も上書きされる  
		```python
		def add_num(num):
		    num = num + 3
		    return num
		a = 1
		b = add_num(a)
		print(a) # 1
		print(b) # 4
		```
	- 引数numを上書きしているように見えて、元のnumは変わらない
- イミュータブルなオブジェクト（変更不可能なオブジェクト）  
	- 文字列や整数型など  
	- 関数による参照元の値は上書きされない  
		```python
		def add_num(n_list):
			n_list[1] = 999
			return n_list
		list_1 = [2, 4, 1, 5]
		list_2 = add_num(list_1)
		print(list_1) # [2, 999, 1, 5]
		print(list_2) # [2, 999, 1, 5]
		```
	- 元の引数n_list自体が上書きされている
## ミュータブルオブジェクトのコピーについて  
リストなどのミュータブルなオブジェクトを関数に渡すと元の値まで上書きされてします。  
これを防ぐために元のミュータブルオブジェクトをコピーする。  
### コピーの種類  
- 浅いコピー  (from copy import copy)  
	- 関数に渡すと元のデータも変わる   
	```python
	from copy import copy
	def add_num(n_list):
		n_list[0][1] = 999
		return n_list
	list_1 = [[2, 4], 1, 5]
	list_2 = copy(list_1)
	add_num(list_2)
	print(list_1) # [[2, 999], 1, 5] ←もとのデータも変わる
	print(list_2) # [[2, 999], 1, 5]
	```
	- リストの中身のidは元リストの中身のidと等しい。  
	- つまり、copyで作られたオブジェクトは元のオブジェクトに格納されているデータを参照している。  
- 深いコピー  (from copy import deepcopy)  
	- 関数に渡しても元のデータは変わらない。  
	```python
	from copy import deepcopy
	def add_num(n_list):
		n_list[0][1] = 999
		return n_list
	list_1 = [[2, 4], 1, 5]
	list_2 = deepcopy(list_1)
	add_num(list_2)
	print(list_1) # [[2, 4], 1, 5] ←もとのデータは変わらない
	print(list_2) # [[2, 999], 1, 5]
	```
	- リストの中身のidは元リストの中身のidと**違う**。  
	- つまり、deepcopyで作られたオブジェクトは見た目は同じでも別のデータを作成している。  
- コピーの種類によるidの違い
	```python
	from copy import copy, deepcopy
	list_1 = [[2, 4], 1, 5]
	list_1_copy = copy(list_1)
	list_1_deep = deepcopy(list_1)
	# リストオブジェクトのidは3つとも異なる
	print(f'list_1: {id(list_1)}') # id:1684270046272
	print(f'list_1_copy: {id(list_1_copy)}') # id:1684270045632
	print(f'list_1_deep: {id(list_1_deep)}') # id:1684270046336
	# リストの中身のidは元のリストと浅いコピーは同じ、深いコピーは異なる
	print(f'list_1[0]: {id(list_1[0])}') # id:1684270245184 浅いコピーと同じid
	print(f'list_1_copy[0]: {id(list_1_copy[0])}') # id:1684270245184 元のリストの中身と同じid（元リストのデータを参照している）
	print(f'list_1_deep[0]: {id(list_1_deep[0])}') # id:1684270046464 違うid（新しいオブジェクトを生成している）
	```
	※list_2 = list_1とした時は、リストオブジェクトも中身のデータも同じidになる。  
# クラス継承
super()で継承元のメソッドを使用する場合、引数を固定化することができる。  
- 独特な形に見えるが、super()で呼び出しているのはメソッドであり、メソッド（関数）を呼び出す際は引数を指定するわけで、その引数の値を決めてしまうという話。  
```python
class Animal:
	def __init__(self, name, species):
		self.name = name
		self.species = species
	def greeting(self):
		print(f'私の名前は{self.name}')
		
# Dogクラスで継承
class Dog(Animal):
	def __init__(self, name, age):
		super().__init__(name, "dog") # speciesを"dog"に固定
		self.age = age
	def greeting_plus(self):
		super().greeting()
		print(f'年齢は{self.age}')

chobi = Dog("チョビ", 5)
# 余談：以下2つは同じ実行結果「私の名前はチョビ」「年齢は5」
chobi.greeting_plus()
Dog.greeting_plus(chobi)
```
## メソッドの呼び出し方
上記コードの最後二つ`chobi.greeting_plus()` `Dog.greeting_plus(chobi)`は、
結果は同じだがメソッドの呼び出し方が異なっている。  
`chobi.greeting_plus()`  
- `chobi`インスタンスから直接メソッドを呼び出す  
- Pythonが自動的に`self`にchobiを渡す  
- 一般的で**推奨される書き方**  
`Dog.greeting_plus(chobi)`  
- Dogクラスから直接メソッドにアクセス  
- `self`引数を**明示的に**渡す必要がある  
- 通常はあまり使わない書き方  
- 特殊な状況(例:継承関係でのメソッド呼び出しなど)でのみ使用する  
