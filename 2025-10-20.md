- calc()　関数
- padding　CSSプロパティ
- box-sizing　CSSプロパティ
- overflow　CSSプロパティ
- display: block　CSSプロパティdisplayにおける指定
- object-fit: contain　CSSプロパティ
学習メモ: イベントハンドラ登録・ホイスティング・関数式の注意点

目的
- ブラウザのイベントハンドラ登録と関数の挙動（ホイスティング、関数式の差）を短くまとめる。
Copilotによる要点（短く）
1) イベントハンドラ登録の基本
- イベントハンドラは登録時ではなく発火時にブラウザからイベントオブジェクトが渡される。ハンドラの引数名は自由（例: e, ev, event）。
- 複数ハンドラが必要なら `addEventListener` を使う。`element.onclick = fn` は最後に代入した1つだけが有効。
- タッチやポインターで `preventDefault()` を使う場合、`addEventListener` のオプションで `{ passive: false }` を考慮する（ブラウザ最適化でデフォルトが passive のことがある）。
1) ホイスティング（関数宣言と変数）
- function 宣言（function foo() {}）は宣言が巻き上げられ、宣言の前でも呼び出せる（ホイスティングされる）。
- var 変数は宣言のみ巻き上げられ、初期化はされないので `undefined` になる。let/const は巻き上げられるが TDZ (Temporal Dead Zone) により宣言前に参照するとエラー。
1) 関数式とアロー関数の注意点
- 関数式（const fn = function(){} / const fn = () => {}）は宣言前に呼べない（変数の初期化が行われるまで不可）。このためイベントハンドラを登録するコードの順序に注意。
- 関数式を const で保持すると accidental reassign を防ぐ利点がある。
1) 実践的な注意点（ドラッグ実装に関して）
- pointer/touch のドラッグは、描画パフォーマンスのために transform: translate() を使うと滑らか。top/left を頻繁に更新するとレイアウトや再描画コストが高くなる。
- absolute ベースで位置を更新する場合、親要素に `position: relative` を付け、最初の位置（offset）を正しくキャプチャしてから top/left を設定する。
- z-index を操作する際は、全 DOM を走査するより対象クラス (`.plant`, `.item` 等) のみを querySelectorAll で選ぶと速い。
短いチェックリスト
- イベント受け取りは発火時（引数名は任意） ✔
- addEventListener を優先、必要なら `{ passive:false }` を指定 ✔
- function 宣言はホイスティングされるが関数式はされない（順序に注意） ✔
- ドラッグは transform を検討、absolute の場合は親に relative を付与 ✔

script.dragfix.js <-> script.js
主な相違点（Copilotによる要点）
- 設計方針
    
    - 旧 ([script.js](vscode-file://vscode-app/c:/Users/uma_w/AppData/Local/Programs/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html))：マウス移動ごとに現在のレイアウト位置（[offsetTop/offsetLeft](vscode-file://vscode-app/c:/Users/uma_w/AppData/Local/Programs/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html)）を参照して style.top/left を更新する方式（差分 pos1/pos2 を用いる）。
    - 新 ([script.dragfix.js](vscode-file://vscode-app/c:/Users/uma_w/AppData/Local/Programs/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html))：ドラッグ開始時に要素の「初期座標」を一度だけ取得し、その後はポインタ差分（dx/dy）を加算して top/left を更新する start+delta 方式に変更（安定化が目的）。
- 位置計算の違い（バグ原因の核心）
    
    - 旧：`marubatsuItem.style.top = (marubatsuItem.offsetTop - pos2) + "px";` のように [offsetTop](vscode-file://vscode-app/c:/Users/uma_w/AppData/Local/Programs/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) を毎回参照して差分を計算 → `position: relative` と組み合わせると top の意味と混ざり、二重計算や「飛ぶ」挙動を起こしやすい。
    - 新：`getBoundingClientRect()` と offsetParent の矩形差から `startLeft` / `startTop` を算出し、`style.left = (startLeft + dx) + 'px'` のように明確に「初期位置＋差分」で更新する。これにより計算が直感的かつ安定する。
- イベントの扱い
    
    - 旧：`marubatsuItem.onpointerdown = pointerDrag;` として直接 on* プロパティを使う実装。移動中は [document.onpointermove](vscode-file://vscode-app/c:/Users/uma_w/AppData/Local/Programs/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) / [document.onpointerup](vscode-file://vscode-app/c:/Users/uma_w/AppData/Local/Programs/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) をセットしている（動作はするが堅牢性に欠ける場面あり）。
    - 新：既存ハンドラを解除してから `addEventListener('pointerdown', ..., { passive:false })` で登録（preventDefault を確実に使える）。`setPointerCapture` / `releasePointerCapture` でポインタ捕捉を試み、ポインタ離脱でもイベントを受け取り続けるよう配慮。
- ポジショニングと表示
    
    - 旧：CSS 側が `.item { position: relative }` のままだと top/left の意味がずれるため消失やずれが起きやすい。
    - 新：ドラッグ開始時に `item.style.position = 'absolute'` を明示し、`item.style.zIndex = '9999'` でドラッグ中は最前面に出す。CSS 側で `.item-holder` を `position: relative`、`.item` を `position: absolute` にする想定で安定動作する設計。
- バインド戦略
    
    - 旧：ページ読み込み時に 16 個それぞれに [dragElement(...)](vscode-file://vscode-app/c:/Users/uma_w/AppData/Local/Programs/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) を呼んでいる。
    - 新：既存ハンドラを解除してから再バインドする形で安全に差し替え（`item.__dragBound` フラグ等で重複バインドを防止）。ファイルは追加（[script.dragfix.js](vscode-file://vscode-app/c:/Users/uma_w/AppData/Local/Programs/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html)）して上書き的に動作させる手法を採用。
- エラー回避と堅牢性
    
    - 新：ブラウザ差分に対する try/catch を一部に入れ、`offsetParent` の不在に対するフォールバックも用意している（[document.body](vscode-file://vscode-app/c:/Users/uma_w/AppData/Local/Programs/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) を fallback にする等）。
    - 新：`pointer capture` を使うことで高速にドラッグしてもイベント取りこぼしが減る。
- パフォーマンス面の注意
    
    - 両者とも現在は top/left を直接更新する方式のため、頻繁更新でレイアウト再計算（reflow）が起き得る。さらに改善するなら transform（translate）＋ requestAnimationFrame を使うと滑らかで負荷が小さい。
- `(function(){ ... })();` は IIFE（Immediately Invoked Function Expression：即時実行関数式）を表す構文。関数を定義すると同時にその場で実行するための書き方。
- 丸括弧 `( ... )` で関数を囲むことで「関数宣言」ではなく「関数式」にし、その後ろの `()` で即時に呼び出している。
- 効果：内部で定義した変数や関数（例：`bindDragToItem`, `rebindAll`）をグローバルスコープに漏らさずローカルに閉じ込められる。ファイル読み込み時に一度だけ初期化処理を実行するのに便利。
closureとの関係一行まとめ：IIFE が「名前の衝突を防ぐ箱」を作り、箱の中で生成されるイベントハンドラ（[pointerDrag](vscode-file://vscode-app/c:/Users/uma_w/AppData/Local/Programs/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) 等）がクロージャとして各アイテムの状態を保持する、という関係。