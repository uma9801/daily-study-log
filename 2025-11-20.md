## DataFrame型への列挿入と並び替え
- `DataFrame名[列名] = 値のリスト`で新たな列を挿入する。（最後尾）  
- `DataFrame名[列名のリスト]`で列の並び順をリスト通りに変更して**出力**。  
	- 変数に代入しないと中身は変化しない。  
## データの加工
- ソート  
	- `DataFrame名.sort_vlues[列名, ascending=True]`  
	- 列名は複数指定可能。リストにせず列挙する形。  
	- ascendingはTrueで昇順、Falseで降順。  
	- `.reset_index()`を後ろにつければソート後のインデックスに振り直せる。  
		- `.reset_index(drop=True)`で振り直し前のインデックス破棄。  
- NaN処理  
	- `DataFrame名.isna()`NaNの要素がTrueを返す。  
	- `DataFrame名.dropna()`NaNが存在しない行のみを抽出。  
	- `DataFrame名.fillna(値orメソッドなど)`NaNの要素を値orメソッドなどで埋める。  
		- 単一の値や文字列、1+1などの計算式、関数：()をつけて関数を呼び出して戻り値を取得する、Series型やDataFrame型も入れられる。  
		- メソッドは`method=""`の形で指定する。  
			- `method="ffill"`直前の有効値で埋める。  
			- `method="bfill"`直後の有効値で埋める。    
- 重複の処理  
	- `DataFrame名.duplicated(列名)`で重複の検出ができる。  
		- 列名を指定しなければ、全ての列の要素が重複している列を検出する。  
		- 返される値はブール配列。  
	- 重複の検出（ブール配列）を使って重複を削除できる。  
		- `DataFrame名[~DataFrame名.duplicated(列名)]`  
		- `~`はNumPyの論理演算子でTrueとFalseを逆転させる。    
- テキストデータの加工  
	- `Series名.strメソッド名`で使用できる文字列メソッドがある。  
		- 使用例：`data_3["部活"].strメソッド名`  
			- DataFrame型の1列を指定すればSeries型になる。  
		- str[start:stop:step]　お馴染みのstartからstopまでスライス。  
			- strと[]の間に`.`は入らないので注意。  
		- str.startswith(文字列)　指定文字列から始まる行を抽出。  
		- str.endswith(文字列)　指定文字列で終わる行を抽出。  
		- str.contains(文字列)　指定文字列を含む行を抽出。  
		- str.strip(文字列)　指定文字列が先頭or末尾にある行に対して指定文字列を削除。  
			- 中間にある文字列は対象外：「おもしろい」に対してstrip(しろ) は効果なし。  
- 関数の適用  
	- `Series名.apply(関数)`で対象のSeries型に関数を適用できる。  
		- 使用例：`data_3["部活_大学時代"] = data_3["部活"].apply(plus_univ)`  
			- 新たな「部活_大学時代」列を挿入し、各値として部活列の要素に関数plus_univを適用した文字列を埋め込む。  
		- 余談：`DataFrame名.fillna(function())`では、fillna()が期待する引数が「埋める値」だったからfuncthion()となり、戻り値を取得する形となった。  
		- apply(関数)では、期待する引数が「実行する関数」なのでfunctionとなり、()はいらない。  
- 要素の置き換え  
	- `Series名.map(置換する辞書)`でテキストデータを辞書のキー：バリューに従って置換できる。  
		- 使用例：`data_3["性別_番号"] = data_3["性別"].map({"男性":0, "女性":1})  
			- 性別_番号列を挿入し、各値として男性を「0」に女性を「1」に置換して埋め込む。  
		- 特定文字列などの**カテゴリ変数**を数字に置き換えてデータを扱える。  
## ベクトル演算（Vectorized Operation)
- 列Aと列Bを足して列Cを作るケースを2次元配列で考える。  
- 1行ずつ値を足していく（for文のイメージ）のではなく、列A全体と列B全体を丸ごとガチャンと足し合わせて結果を出すのがベクトル演算。
- 裏でC言語が処理するので圧倒的に早い。  
- Pythonは動作が遅い言語  。
## パイプラインとラッパー関数
- pandasのリアルな使い方
	- 各処理を小さな関数で作り。
	- 小さな関数をパイプライン(.pipe)で繋げたラッパー関数（パイプライン処理）を作って使う。
	- 処理が丸ごと入った大きな関数にしてしまうと。
		- 可読性が低い。
		- 処理が固定化されて応用性が低い。
		- エラー箇所を特定しにくい。
	- ラッパー関数なら、必要なものを.pipeで入れ、不要な.pipeを削除するだけで使いまわせる。
	- 処理の流れも関数名を追っていけば分かり易い。
	- パイプライン化で重要なメソッド`df.assign(A=...)`
		- 戻り値：列が追加された**新しい**DataFrame。次のメソッドに繋げられる。
		- 既存のシートをコピーして、新しい列を追加したシートを渡してくれるイメージ。
		- `df["A"] = ...`だと、既存のシートに直接書き込むイメージ。
			- 戻り値：なし（None）。Noneに対して次のメソッドは繋げられないので、.pipeで繋げられない。