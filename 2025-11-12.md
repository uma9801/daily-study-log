# 仕事算
Aさん：20日で仕事終わる  
Bさん：30日  
仕事量（全体）：60（20と30の最小公倍数LCM）  
仕事率：A=3（60/20）、B=2 （60/30）  
二人での仕事率：3+2=5  
終了日数：60/5=12日  

# 最小公倍数（Least Common Multipl）
最小公倍数は、大きい値を倍しながら小さい値で割り切れるかチェック。
割り切れればそれが答え。  
``` python
def lcm_by_search(x, y):
	if x == 0 or y == 0:
		return 0
	# 大きい方を base にする
	big, small = max(x, y), min(x, y)
	multiple = big
	while True:
		if multiple % small == 0:
			return multiple
		multiple += big

print(lcm_by_search(24, 10))  # 120
```
# クラス
## クラスの定義
クラスはゲームにおけるキャラクターの設計図のようなもの  
定義方法  
```python
class クラス名:
	処理
```
## インスタンス
クラス（ゲームにおけるキャラクターの設計図）をもとに作成したキャラクターのこと  
クラスを定義していれば、似たインスタンス（キャラクター）を作成しやすい  
```python
# インスタンス名 = クラス名() でインスタンス作成(インスタンス化)
dog_1 = Dog()
```
## メソッド  （=関数）
クラスの機能・処理（キャラクターの動作：戦う・魔法・スキルなど）  
```python
class Dog:
	def greeting(self): # 第一引数はselfで固定
		print(`こんにちは、私の名前はポチです！`)
```
```python
# インスタンス名 = クラス()でインスタンス化
dog_1 = Dog()

# インスタンス化したらメソッドを使用可能
# インスタンス名.メソッド名(引数)でメソッドを使用
dog_1.greeting() # こんにちは、私の名前はポチです！
```

## アトリビュート  
クラスで定義されているデータ枠（キャラクターの持つ値の枠：名前・HP・各ステータスなど）  
インスタンス名.アトリビュート名=値 または インスタンス名.アトリビュート名  
```python
dog_1 = Dog() # Dogクラスからインスタンス化
dog_1.name = '雷神丸' # アトリビュートの定義
print(dog_1.name) # 雷神丸
```
## コンストラクタ  
クラスからインスタンスが作成される時に自動実行される特別なメソッド（関数）  
```python
class Dog:
	# インスタンスが作成されると以下の__init__メソッドが自動的に呼び出される
	# コンストラクタの最初の引数はself。これはインスタンス自身を指す
    # selfを通してインスタンスに属性（変数）を関連付ける
    # self以外の引数を設定することで、インスタンス生成時に外部から値を受け取って初期設定を行う
    def __init__(self, name, breed):
	    # コンストラクタ内で、インスタンスが持つ変数の初期値を設定する
        self.name = name
        self.breed = breed
        print(f"{self.breed}の{self.name}が誕生しました！")
        
my_dog = Dog("ポチ", "柴犬") # 柴犬のポチが誕生しました！
```
## クラス継承  
class クラス名(継承するクラス名):
```Python
class Dog:
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed
        print(f"{breed}の{name}が誕生しました！")
    def greeting(self):
        print("あそぼ")

# DogクラスをHuskyクラスに継承
class Husky(Dog):
    pass # 何も処理をしない

# Dogクラスと同様の引数を使用できる
dog_1 = Husky("チョビ", "シベリアンハスキー")
# Dogクラスのメソッドも使用できる
dog_1.greeting()
```
実行結果：  
シベリアンハスキーのチョビが誕生しました！  
あそぼ  
## オーバーライド  
継承元のクラスのメソッドに変更を加えて使用できるようにする  
```python
class Dog: # クラス定義時には引数はない点に注意
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed
        print(f"{breed}の{name}が誕生しました！")
    def greeting(self):
        print("あそぼ")
# クラス継承
class Husky(Dog):
	# 新たな引数を追加しメソッドの内容を変更
    def __init__(self, name, breed, master):
        # super().メソッド名(self以外の引数)で継承元のメソッドを使用可能
        # メソッド使用なのでselfはいらない点に注意
        # super()の()も忘れがちなので注意
        super().__init__(name, breed)
		    # self.name = name
	        # self.breed = breed を実行したということ
        self.master = master
    def greeting(self):
        super().greeting()
	        # print("あそぼ")　を実行したということ
        print(f"{self.master}：あとで行こうな")
        
dog_1 = Husky("チョビ", "シベリアンハスキー", "ハムテル")
dog_1.greeting()
```
実行結果  
シベリアンハスキーのチョビが誕生しました！  
あそぼ  
ハムテル：あとで行こうな  

