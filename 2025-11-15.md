# pandas (pan(el)-da(ta)-s, Python Data Analysis)
## データの集計・加工に使用されるライブラリ
ライブラリの読み込み：`import pandas as pd`
## Series型
- 値とその値のインデックスを持つ。  
## DataFrame型
- 値とその値のインデックス、そしてインデックスを列とすると行に当たるカラムを持つ。  
- つまり、表形式になっていてインデックス・カラムを指定して値を参照する。  
- excelをイメージすると分かり易い。  
## Series型の作成
- リストをSeries型に変換：`pd.Series(["one", "two", "three","four"])`  
	- index : valueが順に 0:one 1:two 2:three 3:four というSeries型になる。  
- indexを指定して変換：`pd.Series(["one", "two", "three","four"], index=["壱", "弐", "参", "四"])`  
	- index : value = 壱:one 弐:two 参:three 四:four  
	- 辞書型のような値の参照ができる。  
- 辞書をSeries型に変換：`pd.Series(["壱":"one", "弐":"two", "参":"three", "四":"four"])`  
	- index : value = 壱:one 弐:two 参:three 四:four  
## DataFrame型の作成
- リスト型を変換  
	- （多次元）リストをDataFrame型に変換：`pd.DataFrame([["壱", 1], ["弐", 2], ["参", 3], ["四", 4]])`  
		- ![[Pasted image 20251115114656.png|140]]  
		- インデックスやカラムを指定しないと、連番の数字が自動的に割り振られる  
	- インデックスやカラムを指定して変換：`pd.DataFrame([["壱", 1], ["弐", 2], ["参", 3], ["四", 4]], index=["いち", "に", "さん", "よん"], columns=["漢字", "数字"])`  
		- |     | 漢字  | 数字  |
		| --- | --- | --- |
		| いち  | 壱   | 1   |
		| に   | 弐   | 2   |
		| さん  | 参   | 3   |
		| よん  | 四   | 4   |  
- 辞書型を変換
	- 辞書をDataFrame型に変換：`pd.DataFrame({"漢字": {"いち": "壱", "に": "弐", "さん": "参", "よん": "四"}, "数字": {"いち": 1, "に": 2, "さん": 3, "よん": 4}})`  
		- 辞書の場合は、外側のキー（漢字、数字）がカラム、内側のキー（いち、に...）がインデックスとなる  
		- |     | 漢字  | 数字  |
		| --- | --- | --- |
		| いち  | 壱   | 1   |
		| に   | 弐   | 2   |
		| さん  | 参   | 3   |
		| よん  | 四   | 4   |  
# 気づき
- Series型を使うケースの想定  
	- インデックスもカラムもないリストデータで、そのデータが表す意味が一つしかないもの。  
	- 例えば1900年～2000年の日経平均株価の羅列。（1900年,1901年...と値が続く）  
- 辞書型の変換パターン  
	- {キー：バリュー}なので、Series型に変換するときは、似た意味合いのものに変換され{キーつまりインデックス：バリュー}となる。  
	- 同様に、DataFrame型への変換でも{キーつまりカラム：{キーつまりインデックス：バリュー}}となる。  
## データ確認方法（数などの情報）
```python
import numpy as np
np.random.seed(42)
df_2 = pd.DataFrame(np.random.randint(1, 100, (100, 5)), columns=['英語', '数学', '国語', '理科', '社会'])
df_2
```
- 上記のようなデータが多いケースでは、`DataFrame名.head(行数)`, `DataFrame名.tail(行数)`で先頭・末尾から指定行数を表示できる。  
- `DataFrame名.index`でindexの行情報、`DataFrame名.columns`でcolumunsの列情報を取得できる。  
- 行・列の数をまとめて取得するには`DataFrame名.shape`    
## 要素の参照方法
### Series型の参照
- `series[インデックス]`で値を参照できる。  
- `series[インデックス, インデックス, インデックス]`のようにインデックスのリストを入れて複数の値を参照できる。  
	- この時、リスト順に抽出したSeries型となっている。  
### DataFrame型の参照
- 番号で検索できるのは行（インデックス）だけ。列（カラム）は列名が必須。  
- `DataFrame名[行番号or行名でのスライス]`で特定の**行**の抽出ができる。  
	- 抽出した列はDataFrame型となっている。  
	- 行番号・行名**単体で参照するとエラー**になる。  
	- スライスはリストの様にDataFrame名[x:y:z]のように指定可能。  
- `DataFrame名[列名]`で特定の**列**を抽出できる。  
	- [列名のリスト]で複数の列を抽出可能。  
### マルチインデックス
- `index=[[インデックスのリスト], [インデックスのリスト]]`という形で作成すれば、インデックスやカラムを2層,3層とした階層構造にすることができる。  
	- Series, DataFrameどちらも可能。  
	- このようなマルチインデックスによって参照することで、より適した集団を抽出できる。  
	- **注意**：階層構造であるマルチインデックスは、そのままでは参照が上手く行かないケースもある。  
		- `index=[['1組']*20 + ['2組']*20 + ['3組']*20...`は大丈夫だったが、  
		- `index=[['たんぽぽ']*10 + ['ひまわり']*10 + ['ききょう']*10...`は以下のようにソートしなければエラーが出た。  
		- `index=[['1組']*20 + ['3組']*20 + ['2組']*20...`という風に2組と3組の順番を入れ替えると同様のエラーが出た。
			- インデックスが数字のような順序が明確なもので定義され、、1,2,3...と順序通りに並んでいることが加工なしに参照できる条件なのかも？
```python
df_ex_2_sorted = df_ex_2.sort_index()
df_ex_2_sorted.loc['ひまわり':'ゆり']
```
```python
# ソートせずに df_ex_2['ひまわり':'ききょう'] 実行で以下のエラー発生
# 2組と3組の順番を入れ替えて作成したら、df_3['3組': '2組'] の実行もエラー
# df_3['2組': '3組'] としても同様のエラーが発生 
UnsortedIndexError: 'Key length (1) was greater than MultiIndex lexsort depth (0)'
```