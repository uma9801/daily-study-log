# クラス
クラスをもとに作成したものがインスタンス。
# Obsidian：行末スペースの可視化
## 愛用型
```CSS
.cm-trailing-space-new-line::after {
	content:'↵';

	color: limegreen;
	font-family: monospace;
	pointer-events: none;
	user-select: none;
}
```
`pointer-events: none`選択やマウス操作を邪魔しないようにする。  
`use-select: none`は無しでもいいかもですが、以下の保険として併用。  
`font-family: monospace`表示崩れが起きないようにする。  
### use-selectを指定しないときに起こり得るこまりごと
- コピー時にゴミ文字が入る：ノートやコードを選択してコピーすると、可視化マーカー（↵）がコピー結果に混ざる・貼り付け先で邪魔になる。  
- 選択の見た目が崩れる：行選択やドラッグ選択でマーカーもハイライトされ、どこを選んでいるか分かりにくくなる。  
- ダブルクリック／単語選択の挙動がおかしくなる：単語をダブルクリックしたときにマーカーが隣接していると選択範囲が期待通りにならない。  
- モバイルでの選択ハンドルが邪魔：長押しで表示される選択ハンドルがマーカーに触れて操作性が落ちる。  
### monospaceフォントファミリー
今回の↵のようなマーカーの可視化に向く等幅フォント。  
各文字が同じ幅なのでマーカーが期待通りの位置に出る。  
記号や矢印などのグリフが崩れにくい。  
## スペース1つずつ可視化型
``` CSS
.cm-trailing-space-a,
.cm-trailing-space-new-line {
	outline: 1px dotted palegreen;
}
```
## 遊び心型
```CSS
.cm-trailing-space-new-line::after {
	content: '🐎🎵🐽👻🧸👍✍️';
	pointer-events: none;
	user-select: none;
}
```
好きな絵文字を改行マークにすることもできます  
## 参考資料
https://laboradian.com/visualize-spaces-at-the-end-of-lines-in-obsidian-edit-mode/
https://wineroses.hatenablog.com/entry/2023/07/31/160811
上記記事を参考にしました。
### 1つ目の参考コード
``` CSS
.cm-trailing-space-a,
.cm-trailing-space-b,
.cm-trailing-space-new-line {
	border: 1px solid LightPink;
}
```
各クラスを持つ要素に対し、1pxの色付き枠線をつけるスタイルを定義している。
具体的には、行末のスペースを2つ付けた時点で色付きの枠線がスペースの個数分表示されるようになる。
#### `border`と`outline`どちらが良いか？
##### border
要素ボックスの一部(box model)。
幅を持つので要素の幅・レイアウトが変わる（行の高さがずれることがある）。  
##### outline
ボックスモデルの外側に描画され、レイアウトや要素のサイズを変えない
（フォーカスリングによく使われる。ex.マウスでクリックした所の枠が強調される）。
レイアウトを壊さずに枠を表示できる。
描画がブラウザ依存になりやすいので、精密な見た目制御が必要ならborderにする方が確実。

### 2つ目の参考コード
```CSS
.cm-trailing-space-a,
.cm-trailing-space-b,
.cm-trailing-space-new-line::before{
	content:'↵';
	color:skyblue;
}
```
スペースに印をつけるのではなく、
`::before`を使って改行要素の前に ↵ を表示する。
# ジェネレータ
#50 ジェネレーター（Generator）  
`return` の代わりに `yield` を使うのが特徴。  
関数の途中経過を「一時停止」して値を順に返せる仕組み。  
大量データを一気に作らず、必要な分だけ生成できる。

途中で一時停止して値を返せる関数。  
通常の関数：一度に結果を全部返す。  
ジェネレータ：結果をため込まず、必要な分だけ値を順に返して処理を続行できる。そのためメモリ効率が良く、大量データ処理やストリーム処理に向いている。  

for文での利用：`for`文でループすると、自動で`next()`を繰り返してくれる
``` Python
def count_up_to(n):
    count = 1
    print("First count:", count)
    while count <= n:
        print("Counting:", count)
        yield count # ここで値を返して一時停止し、再開時はここから実行される
        print("Yielded:", count)
        count += 1

for num in count_up_to(3):
    print(num)
```

``` Python
# 実行結果
First count: 1
Counting: 1
1
Yielded: 1
Counting: 2
2
Yielded: 2
Counting: 3
3
Yielded: 3
```