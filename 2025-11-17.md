# データの集計
## カウント
- 各値の出現数をカウントする：`DataFrame名[列名].value_counts()`  
	- **カウントする範囲を絞る**：  
	- `DataFrame名[DataFrame名[列名] 条件式][列名].value_counts()`  
	- 例：`df_2[df_2['理科'] <= 10]['理科'].value_counts()`  
		- ①`df_2['理科'] <= 10`が実行され、理科が10以下を判定基準としたTrue, FalseのSeries型が作られる。  
		- ②`df_2[df_2['理科'] <= 10]`が実行され、①のSeries型を基に、df_2についてTrueの箇所だけが抽出たDataFrame型が作られる。  
			- `df_2[①のSeries型]`というイメージ。  
		- ③`df_2[df_2['理科'] <= 10]['理科'].value_counts()`が実行され、②のDataFrame型を基に、'理科'の列の集計が出力される。  
			- `②のDataFrame型['理科'].value_counts()`というイメージ。  
## グループ集計
- 列を指定し値毎にグループ化する：`DataFrame名.groupby[列名]`  
	- グループ化するメソッドなので、これだけでは表示されない。  
	- max(), mean(), describe(), などのメソッドを加えて出力させる。  
	- 例：`df_4.groupby['職業'].max()`  
		- 職業でグループ分けされ、’学生’の行、’社会人’の行など値ごとに列がまとまる。  
		- max()により、グループ分けされた行ごとに、’年齢’の列、’身長’の列など各列の最大値が出力される。  
## ビニング処理
- 値をレンジごとに区切ってカテゴリ分けする処理。
	- **レンジ幅**を均等にして分ける`pd.cut(ビニングする配列, 分割数)`
		- 例：`pd.cut(df_2["理科"], 4)`
			- 値ごとにどのレンジ幅に属しているかが出力される。
			- `print(cut_bins.cat.categories)`でビニングされた結果を出力するとどんなレンジ幅でカテゴリ分けされたかわかる。
			- (0.904, 25.0], (25.0, 49.0], (49.0, 73.0], (73.0, 97.0]　※必要部分を抜粋したもの
	- 各レンジに**含まれる要素数**を均等にして分ける`pd.qcut(ビニングする配列, 分割数)`
		- 例：`pd.qcut(df_2["理科"], 4)`
			- `print(qcut_bins.cat.categories)`
			- (0.999, 19.0], (19.0, 36.0], (36.0, 59.25], (59.25, 97.0]
		- qcutのqは**quantile (クォンタイル、分位数)**
			- クォンタイルとは、データを小さい方から並べたときに、データを等しい数に分割する点のことを指す。
	- `print(cut_bins.cat.categories)`について
		- 前提として、`cut_bins = pd.cut(df_2["理科"], 4)`という前処理をしてある。
			- 上記処理により、cut_binsは`pandas.Series`オブジェクトとして作成されている。
			- このSeriesのデータ型は`categorical`
		- .`cat`は「カテゴリカルアクセサ」と呼ばれる。
			- Seriesのデータ型がcategoricalの時、`.cat`を付けるとカテゴリデータにアクセスできるようになる。
		- `.categories`は、.catアクセサでアクセスできる属性の一つ。  
			- `categorical`型のデータが持っている「定義されたカテゴリ（分類の項目）」の一覧を返す。
				- 今回は、.cutや.qcut関数で作成された「区画（ビン）のリスト」